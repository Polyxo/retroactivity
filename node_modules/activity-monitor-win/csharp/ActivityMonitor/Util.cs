using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Drawing;
using ColorMine.ColorSpaces;

namespace ActivityMonitor
{
    public class Util
    {
        [DllImport("user32.dll", SetLastError = true)]
        static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);

        public static Color GetIconColor(Bitmap bmp)
        {
            float rtotal = 0;
            float gtotal = 0;
            float btotal = 0;
            float total = 0;

            for (int y = 0; y < bmp.Height; y++)
            {
                for (int x = 0; x < bmp.Width; x++)
                {
                    Color c = bmp.GetPixel(x, y);

                    //float saturation = (Math.Max(c.R, Math.Max(c.G, c.B)) - Math.Min(c.R, Math.Min(c.G, c.B))) / 255.0f;
                    float saturation = c.GetSaturation();
                    float relevance = .1f + .9f * (c.A / 255.0f) * saturation;

                    rtotal += (c.R * relevance);
                    gtotal += (c.G * relevance);
                    btotal += (c.B * relevance);

                    total += relevance * 255;
                }
            }

            Color color = Color.FromArgb(255, (int)(rtotal / total * 255), (int)(gtotal / total * 255), (int)(btotal / total * 255));

            var rgb = new Rgb { R = color.R, G = color.G, B = color.B };
            var hsv = rgb.To<Hsv>();
            if (hsv.S > 0.15f)
            {
                hsv.S = 0.75f; //values slightly tweaked here from the original
            }
            hsv.V = 0.8f;
            rgb = hsv.To<Rgb>();

            return Color.FromArgb(255, (int)rgb.R, (int)rgb.G, (int)rgb.B);
        }

        public static Process GetProcessByWindow(IntPtr handle)
        {
            uint processId;
            GetWindowThreadProcessId(handle, out processId);
            return Process.GetProcessById((int)processId);
        }
    }
}