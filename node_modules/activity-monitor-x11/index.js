var x11 = require("x11");
var Promise = require("promise");
var x11prop = require("x11-prop");
var getProperty = Promise.denodeify(x11prop.get_property);
var setProperty = Promise.denodeify(x11prop.set_property);
var fsp = require('fs-promise');
var fs = require('fs');
var ini = require('ini');
var gettext = require("gnu-gettext");
var PNG = require('pngjs').PNG;
var promisePipe = require('promisepipe');
var dataurl = require('dataurl');
var concatStream = require('concat-stream');
var util = require('./util.js');
var Color = require('color');

function ActivityMonitor()
{
  var that = this;
  
  gettext.setLocale("LC_ALL", "de_DE.UTF-8");
  this.x11 = require('x11');
  
  this.initialised = new Promise(function (resolve, reject) {
  
    that.x11.createClient(function(err, display)
    {
      if (!err)
      {
        that.display = display;
        resolve(that);
      }
      else
      {
        reject(err);
      }
    });
  
  });
};

ActivityMonitor.Window = function Window(am, id)
{
  this.am = am;
  this.id = id;
  
  var that = this;
  this.initialised = this.am.initialised.then(function()
    {
      X = that.am.display.client;
      return getProperty(X, that.id, '_BAMF_DESKTOP_FILE', 'STRING');
    }).then(function(desktopFilePath)
    {
      return fsp.readFile(desktopFilePath.toString(), {encoding:'utf8'});
    }).then(function(desktopFileContent)
    {
      that.desktopFile = ini.parse(desktopFileContent);
      return that;
    }).catch(function(err)
    {
      console.log("Cannot load desktop file, reason:", err);
      return that;
    });
};

function findTopWindow(X, window)
{
  var i = 0;
  return new Promise(function(resolve, reject)
  {
    var recurse = function(window, err, node)
    {
      i++;
      if(!err)
      {
        if(node.parent == node.root)
        {
          resolve(window);
        }
        else
        {
          try
          {
            getProperty(X, window, 'WM_NAME', 'STRING').then(function(prop)
            {
              console.log('node', node, prop);
              if(!prop || prop.length == 0)
              {
                X.QueryTree(node.parent, recurse.bind(null, node.parent));
              }
              else if(window)
              {
                resolve(window);
              }
            }).catch(function(err)
            {
              reject(err);
            });
          }
          catch(e)
          {
            reject(e);
          }
        }
      }
      else
      {
        console.log(err);
        reject(err);
      }
    };
    
    X.QueryTree(window, recurse.bind(null, window));
  });
}

function getNetActiveWindow(X, display)
{
  return getProperty(X, display.screen[0].root, '_NET_ACTIVE_WINDOW', 'WINDOW').then(function(prop)
  {
    if(prop.length > 0)
      return prop[0];
    else
      throw "finding _NET_ACTIVE_WINDOW failed";
  });
};

ActivityMonitor.prototype =
{
  getActiveWindow: function()
  {
    var that = this;
    var X = null;
    return that.initialised.then(function()
    {
      X = that.display.client;
      return getNetActiveWindow(X, that.display);
    })
    .catch(function(err)
    {
      //try different strategy
      var XGetInputFocus = Promise.denodeify(X.GetInputFocus);
      return XGetInputFocus.call(X).then(function(result)
      {
        return findTopWindow(X, result.focus);
      });
    })
    .then(function(window)
    {
      return new ActivityMonitor.Window(that, window);
    });
  }
};

ActivityMonitor.Window.prototype =
{
  getProgramName: function()
  {
    var that = this;
    var X = null;
    return that.am.initialised.then(function()
    {
      X = that.am.display.client;
      return getProperty(X, that.id, 'WM_CLASS', 'STRING');
    }).then(function(result)
    {
      if(result && result.length == 2)
      {
        this.programName = result[1].toString();
        return result[1].toString();
      }
      else
      {
        return 'unknown';
      }
    });
  },
  
  getLocalisedProgramName: function()
  {
    var that = this;
    var X = null;
    return that.initialised.then(function()
    {
      X = that.am.display.client;
      var locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG;
      if(!that.desktopFile)
      {
        return that.getProgramName();
      }
      
      if(that.desktopFile['Desktop Entry']['GenericName['+locale+']'])
      {
        return that.desktopFile['Desktop Entry']['GenericName['+locale+']'];
      }
      locale = locale.replace(/\..+$/, '');  //remove encoding
      if(that.desktopFile['Desktop Entry']['GenericName['+locale+']'])
      {
        return that.desktopFile['Desktop Entry']['GenericName['+locale+']'];
      }
      locale = locale.replace(/_..$/, '');  //remove country code
      if(that.desktopFile['Desktop Entry']['GenericName['+locale+']'])
      {
        return that.desktopFile['Desktop Entry']['GenericName['+locale+']'];
      }
      
      if(that.desktopFile['Desktop Entry']['X-Ubuntu-Gettext-Domain'])
      {
        gettext.textdomain (that.desktopFile['Desktop Entry']['X-Ubuntu-Gettext-Domain']);
        return gettext.gettext(that.desktopFile['Desktop Entry']['GenericName']);
      }
      else
      {
        return that.getProgramName();
      }
    });
  },
  
  getDocumentName: function()
  {
    
  },
  
  getRawIcon: function(targetSize)
  {
    if(typeof targetSize != "number")
      targetSize = 1000 * 1000;
    else
      targetSize *= targetSize; //compare the square!
    
    var that = this;
    var X = that.am.display.client;
    return this.iconPromise = getProperty(X, that.id, '_NET_WM_ICON', 'CARDINAL').then(function(result)
    {
      if(result.length == 0)
        return undefined;
      //see here for specifications of the _NET_WM_ICON property: http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#idm140200472568384
      var width = 0;
      var height = 0;
      var best_offset = 0;
      var best_score = 10000000;
      //search for the biggest icon in the set
      for(var i = 0; i < result.length; i += width*height + 2)
      {
        width = result[i];
        height = result[i+1];
        var score = Math.abs(width * height - targetSize);
        if(score < best_score && result.length >= i+width*height+2)
        {
          best_offset = i;
          best_score = score;
        }
      }
      
      //unpack data into png object
      width = result[best_offset];
      height = result[best_offset+1];
      var img = new PNG({width: width, height: height});
      
      for(var i = 0; i < width*height; i++)
      {
        var pixel = result[best_offset+2+i];
        //pngjs need bytewise rgba, we have packed argb
        img.data[i*4    ] = (pixel >> 16) & 255;
        img.data[i*4 + 1] = (pixel >>  8) & 255;
        img.data[i*4 + 2] = (pixel      ) & 255;
        img.data[i*4 + 3] = (pixel >> 24) & 255;
      }
      
      return img;
    });
  },
  
  getIcon: function(size)
  {
    return this.getRawIcon(size).then(function(img)
    {
      if(!img)
        return img;
      
      return promisePipe(img.pack(), concatStream())
      .then(function(streams)
      {
        return Buffer.concat(streams[1].body);
      });
    });
  },
  
  getColor: function()
  {
    var that = this;
    if(!this.desktopFile || (this.desktopFile && !this.desktopFile['Desktop Entry']['X-Unity-IconBackgroundColor']))
    {
      if(that.color)
        return Promise.resolve(that.color);
      else if(this.iconPromise)
        return this.iconPromise.then(function(icon) { if(icon) return util.colorForIcon(icon).toString(); else return null; });
      else
        return this.getRawIcon(48).then(function(icon) { if(icon) return util.colorForIcon(icon).toString(); else return null; });
    }
    else
    {
      return Promise.resolve(new Color(this.desktopFile['Desktop Entry']['X-Unity-IconBackgroundColor']).toString());
    }
  },
  
  //get a plain object with information used to match windows by application
  getKeyObject: function()
  {
    var properties =
      [
        [ 'desktopFile', '_BAMF_DESKTOP_FILE', 'STRING' ],
        [ 'pid',         '_NET_WM_PID', 'CARDINAL' ],
        [ 'class',       'WM_CLASS', 'STRING' ],
        [ 'gtkWinID',    '_GTK_APPLICATION_ID', 'UTF8_STRING' ],
        [ 'windowRole',  'WM_WINDOW_ROLE', 'STRING' ],
        [ 'windowTitle', 'WM_NAME', 'STRING' ],
        [ 'windowTitle', 'WM_NAME', 'UTF8_STRING' ],
        [ 'windowTitle', '_NET_WM_NAME', 'UTF8_STRING' ]
      ];
    
    var X = this.am.display.client;
    var that = this;
    
    var operations = properties.map(function(spec)
    {
      return Promise.all([ spec[0], getProperty(X, that.id, spec[1], spec[2])]);
    });
    
    operations.push(['windowID', this.id]);
    
    return Promise.all(operations).then(function(results)
    {
      var obj = {};
      results.forEach(function(result)
      {
        var value = result[1];
        if(value instanceof Array)
        {
          value = value.map(function(x) { return x instanceof Buffer ? x.toString() : x; });
          if(value.length == 1)
            value = value[0];
          else if(value.length == 0)
            value = undefined;
          else
            value = value.join(' ');
        }
        if(typeof value != undefined)
          obj[result[0]] = value;
      });
      
      return obj;
    });
  },
  
  getFrozen: function()
  {
    return Promise.all(
    [
      'id', this.id,
      'programName', this.getProgramName(),
      'localisedProgramName', this.getLocalisedProgramName(),
      'icon', this.getIcon(48),
      'color', this.getColor()
    ]).then(function(result)
    {
      var obj = { };
      for(var i = 0; i < result.length; i += 2)
      {
        obj[result[i]] = result[i+1];
      }
      return obj;
    });
  }
};

ActivityMonitor.Window.exampleKey = 
{
  windowID: 123,
  pid: 123,
  desktopFile: '/some/path',
  'class': 'some_string',
  gtkWinID: 'some_string',
  windowRole: 'some_string',
  windowTitle: 'some_string'
};

ActivityMonitor.Window.exampleData =
{
  'programName': 'some_string',
  'localisedProgramName': 'some_string',
  'icon': new Buffer(['1', '2', '3']),
  'color': '#123456'
};

ActivityMonitor.Window.keyScores =
{
  windowID: 12,
  pid: 10,
  'class': 2,
  desktopFile: 8,
  gtkWinID: 4,
  windowRole: 1,
  windowTitle: 3
}

ActivityMonitor.Database = require('./database');

module.exports = ActivityMonitor;
